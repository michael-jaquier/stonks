// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package store

import (
	"context"
	"database/sql"
	"time"
)

const createOrGetTicker = `-- name: CreateOrGetTicker :one
INSERT INTO inventory_symbol (symbol)
VALUES (?)
ON CONFLICT(symbol) DO UPDATE SET
    symbol = excluded.symbol
RETURNING symbolid, symbol
`

func (q *Queries) CreateOrGetTicker(ctx context.Context, symbol string) (InventorySymbol, error) {
	row := q.db.QueryRowContext(ctx, createOrGetTicker, symbol)
	var i InventorySymbol
	err := row.Scan(&i.Symbolid, &i.Symbol)
	return i, err
}

const createTicker = `-- name: CreateTicker :one
INSERT INTO inventory_symbol (symbol)
VALUES (?)
RETURNING symbolid, symbol
`

func (q *Queries) CreateTicker(ctx context.Context, symbol string) (InventorySymbol, error) {
	row := q.db.QueryRowContext(ctx, createTicker, symbol)
	var i InventorySymbol
	err := row.Scan(&i.Symbolid, &i.Symbol)
	return i, err
}

const deleteWeeklyPrices = `-- name: DeleteWeeklyPrices :exec
DELETE FROM weekly_prices
WHERE week_start = ?
`

func (q *Queries) DeleteWeeklyPrices(ctx context.Context, weekStart time.Time) error {
	_, err := q.db.ExecContext(ctx, deleteWeeklyPrices, weekStart)
	return err
}

const insertDailyPrice = `-- name: InsertDailyPrice :one
INSERT INTO prices (symbolid, trading_day, open, close)
VALUES (?, ?, ?, ?)
RETURNING symbolid, trading_day, open, close, delta, pct_delta
`

type InsertDailyPriceParams struct {
	Symbolid   int64
	TradingDay time.Time
	Open       float64
	Close      float64
}

func (q *Queries) InsertDailyPrice(ctx context.Context, arg InsertDailyPriceParams) (Price, error) {
	row := q.db.QueryRowContext(ctx, insertDailyPrice,
		arg.Symbolid,
		arg.TradingDay,
		arg.Open,
		arg.Close,
	)
	var i Price
	err := row.Scan(
		&i.Symbolid,
		&i.TradingDay,
		&i.Open,
		&i.Close,
		&i.Delta,
		&i.PctDelta,
	)
	return i, err
}

const insertWeeklyPrices = `-- name: InsertWeeklyPrices :exec
;


INSERT INTO weekly_prices (symbolid, week_start, open, close)
SELECT
    symbolid,
    week_start,
    FIRST_VALUE(open) OVER w AS open,
    LAST_VALUE(close) OVER w AS close
FROM (
  SELECT
    symbolid,
    trading_day,
    open, 
    close,
    date(trading_day, 'weekday 1', '-7 days') as week_start
  FROM prices
  where trading_day >= ? and trading_day < date(trading_day, '+7 days')
)
GROUP BY (symbolid, week_start)
WINDOW w AS (
  PARTITION by (symbolid, week_start)
  ORDER BY trading_day
  ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
)
`

func (q *Queries) InsertWeeklyPrices(ctx context.Context, tradingDay time.Time) error {
	_, err := q.db.ExecContext(ctx, insertWeeklyPrices, tradingDay)
	return err
}

const pctTopN = `-- name: PctTopN :many
SELECT
    p.symbolid,
    s.symbol,
    p.trading_day,
    p.pct_delta
FROM prices p
JOIN inventory_symbol s
  ON p.symbolid = s.symbolid
WHERE p.trading_day = ?
ORDER BY p.pct_delta DESC
LIMIT ?
`

type PctTopNParams struct {
	TradingDay time.Time
	Limit      int64
}

type PctTopNRow struct {
	Symbolid   int64
	Symbol     string
	TradingDay time.Time
	PctDelta   sql.NullFloat64
}

func (q *Queries) PctTopN(ctx context.Context, arg PctTopNParams) ([]PctTopNRow, error) {
	rows, err := q.db.QueryContext(ctx, pctTopN, arg.TradingDay, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PctTopNRow
	for rows.Next() {
		var i PctTopNRow
		if err := rows.Scan(
			&i.Symbolid,
			&i.Symbol,
			&i.TradingDay,
			&i.PctDelta,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
